package grakn.benchmark.profiler.generator.provider.concept;

import grakn.benchmark.profiler.generator.storage.ConceptStorage;
import grakn.benchmark.profiler.generator.util.WeightedPicker;
import grakn.core.concept.ConceptId;

import java.util.Random;

/**
 * A Concept provider that does a simple linear weighting by row number (~= age)
 * So that more recently created entries have a higher probability of being returned
 *
 * Takes a parameter adjusting how much subsequent rows grow in weight compared to the prior one
 */


// deprecated because it doesn't seem to be incredibly useful right now!
// goal was to weight more recently inserted concepts as a proxy for concepts with fewer relationships,
// thus (hopefully) flattening the supernode-y structures being generated by randomly connecting vertices
// however, due to nature of randomness & this being a proxy for weighting directly by number of relationships
// it doesn't perform too well
@Deprecated
public class AgeWeightedConceptIdProvider implements ConceptIdProvider {

    private Random rand;
    private ConceptStorage conceptStorage;
    private String typeLabel;
    private double ageWeightIncrement;

    public AgeWeightedConceptIdProvider(Random rand, ConceptStorage conceptStorage, String typeLabel, double ageWeightIncrement) {
        this.rand = rand;
        this.conceptStorage = conceptStorage;
        this.typeLabel = typeLabel;
        this.ageWeightIncrement = ageWeightIncrement;
    }

    @Override
    public boolean hasNext() {
        return conceptStorage.getConceptCount(typeLabel) > 0;
    }

    @Override
    public boolean hasNextN(int n) {
        return conceptStorage.getConceptCount(typeLabel) >= n;
    }

    @Override
    public ConceptId next() {
        int conceptCount = conceptStorage.getConceptCount(typeLabel);

        // create weighted picker, row 1 has weight 1, row 2 has weight 2...
        WeightedPicker<Integer> weightedPicker = new WeightedPicker<>(rand);
        for (int i = 0; i < conceptCount; i++) {

//            double weight = 1 - Math.pow(2, -5 * ageWeightIncrement * (i + 1) / (conceptCount + 1.0));
//            double weight = 1 + i*ageWeightIncrement;


            // ageWeightIncrement is 0 => weights equiprobable
            // ageWeightIncrement is 1 => Most recent row is probability 0.5, prior is 0.25, prior is 1/8, prior is 1/16...
            // With this weight calculation, setting between 0.2 (mostly picks most recent rows) and 0.00001 (closer to random) seems to provide best results
            // In some experiments ~0.0001 appears to perform pretty well, reducing orphan attributes from about 1/2 -  1/3 to 1/4 of inserted concepts
            double weight = Math.pow(2, -1 * ( conceptCount - i) * ageWeightIncrement);
            weightedPicker.add(weight, i);
        }

        int randomRowOffset = weightedPicker.sample();

        return conceptStorage.getConceptId(typeLabel, randomRowOffset);
    }
}
